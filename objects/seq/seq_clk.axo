<objdefs appVersion="1.0.9">
  <obj.normal id="seq_clk" uuid="de6909eb611b13af5b43f97484c130024b3a4793">
    <sDescription>Sequencer clock controller</sDescription>
    <author>Are LEistad</author>
    <license>BSD</license>
    <helpPatch>lfo.axh</helpPatch>
    <inlets>
      <frac32.bipolar  name="freq"       description="Clock frequency mod"/>
      <frac32.bipolar  name="gatelength" description="Gate length mod"/>
      <bool32          name="run"        description="Enable playing"/>
      <bool32          name="reverse"    description="Play backwards"/>
      <bool32.rising   name="rstsync"    description="Reset to step 0 on next clock"/>
      <bool32.rising   name="rstimm"     description="Reset to step 0 immediately"/>
    </inlets>
    <outlets>
      <int32  name="step"  description="Step number out"/>
      <bool32 name="gate"  description="Gate/clock out"/>
      <bool32.pulse name="start" description="Pulse when step 1 starts"/>
    </outlets>
    <displays/>
    <params>
      <frac32.s.map.lfopitch name="freq"       description="Clock frequency modulation"/>
      <frac32.u.map.ratio    name="gatelength" description="Gate length"/>
      <int32 name="seqlength" noLabel="false">
         <MinValue i="1"/>
         <MaxValue i="16"/>
      </int32>
    </params>
    <attribs>
    </attribs>
    <code.declaration><![CDATA[

      uint32_t  phase;
      uint32_t  old_phase;
      uint32_t  old_reset_sync;
      uint32_t  old_reset_imm;
      uint32_t  reset_sync;
      uint32_t  reset_imm;
      uint32_t  supress_trig;    // Avoid new gate on currentstep for stop -> run
      uint32_t  enforce_trig;    // Ensure that we get a retrigger on reset immediate if pressed when gate was on
      uint32_t  start_pulse;
      uint32_t  first_run;
      int       count;
      int       old_count;

    ]]></code.declaration>
    <code.init><![CDATA[

      phase           = 0;
      old_phase       = 0;
      old_reset_sync  = 0;
      old_reset_imm   = 0;
      reset_sync      = 0;
      reset_imm       = 0;
      supress_trig    = 0;
      enforce_trig    = 0;
      start_pulse     = 0;
      first_run       = 1;
      count           = 0;
      old_count       = 0;


    ]]></code.init>
    <code.krate><![CDATA[

      int32_t freq;
      int32_t gatelength;

      // Catch counter reset requests, with immedita reset taking priority
      if( inlet_rstimm > 0 && old_reset_imm == 0 )
        {
          reset_imm = 1;
        }
      else if( inlet_rstsync > 0 && old_reset_sync == 0 )
        {
          reset_sync = 1;
        }
      old_reset_sync = inlet_rstsync;
      old_reset_imm  = inlet_rstimm;

      if( inlet_run )
        {
          MTOFEXTENDED( param_freq + inlet_freq ,freq );
          phase += freq>>2;

          if( first_run )
            {
              // Need to force a start pulse the very first run, since no count will trigger before the seconf step
              start_pulse = 1;
              first_run   = 0;
            }
          else if( phase < old_phase || first_run )
            {
              // Update counter
              if( inlet_reverse != 0 )
                {
                  count--;
                  if( count < 0 )
                    count = param_seqlength - 1;
                }
              else
                {
                  count++;
                  if( count >= param_seqlength )
                    count = 0;
                }
              if( count == 0 )
                start_pulse = 1;
            }

          // Handle counter reset, either immediate of synchronized to the clock
          if( reset_imm == 1 )
            {
              phase         = 0;
              reset_imm     = 0;
              reset_sync    = 0;
              count         = 0;
              enforce_trig  = 1;
            }
          else if( reset_sync == 1 )
            {
              if( phase < old_phase )
                {
                  phase         = 0;
                  reset_imm     = 0;
                  reset_sync    = 0;
                  count         = 0;
                }
            }

          gatelength = param_gatelength + inlet_gatelength;
          if( gatelength > (1<<27) )
            gatelength  = (1<<27);
          else if( gatelength < 0 )
            gatelength  = 0;

          if( supress_trig )
            {
              outlet_gate = 0;
              if( count != old_count )
                supress_trig = 0;
            }
          else if( enforce_trig )
            {
              outlet_gate  = 0;
              enforce_trig = 0;
            }
          else
            {
              if( (phase>>5) > gatelength )
                outlet_gate = 0;
              else
                outlet_gate = 1;
            }

          outlet_step  = count;
          outlet_start = start_pulse;
          start_pulse  = 0;
          old_count    = count;
          old_phase    = phase;
        }
      else
        {
          outlet_gate  = 0;
          outlet_start = 0;
          outlet_step  = count;
          supress_trig = 1;
        }

    ]]></code.krate>
  </obj.normal>
</objdefs>