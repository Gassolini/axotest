<objdefs appVersion="1.0.9">
  <obj.normal id="seq_clk_midi" uuid="de6909eb627413af5b43f97184c1306f4b3a4793">
    <sDescription>Sequencer clock controller, midi/24ppq sync</sDescription>
    <author>Are Leistad</author>
    <license>BSD</license>
    <inlets>
      <frac32.bipolar  name="tempo"      description="Clock frequency mod"/>
      <frac32.bipolar  name="gatelength" description="Gate length mod"/>
      <bool32          name="run"        description="Run/stop"/>
      <!-- bool32          name="runsync"    description="Run/stop synced to next clock"/ -->
      <bool32          name="reverse"    description="Play backwards"/>
      <bool32.rising   name="rstsync"    description="Reset to step 0 synved to next clock"/>
      <bool32.rising   name="rstimm"     description="Reset to step 0 immediately"/>
      <bool32.rising   name="24ppq"      description="External 24 PPQ clock"/>
    </inlets>
    <outlets>
      <int32  name="step"           description="Step number out"/>
      <bool32 name="gate"           description="Gate/clock out"/>
      <bool32.pulse name="clock"    description="Step clock output"/>
      <bool32.pulse name="24ppq"    description="24 PPQ clock output"/>
      <bool32.pulse name="start"    description="Pulse when step 1 starts"/>
    </outlets>
    <displays/>
    <params>
      <int32 name="clockdiv" noLabel="false">
         <MinValue i="1"/>
         <MaxValue i="48"/>
      </int32>
      <bool32.tgl            name="miditransport" description="Obey MIDI transport messages"/>
      <frac32.s.map.lfopitch name="tempo"         description="Clock frequency modulation"/>
      <frac32.u.map.ratio    name="gatelength"    description="Gate length"/>
      <int32 name="seqlength" noLabel="false">
         <MinValue i="1"/>
         <MaxValue i="64"/>
      </int32>
    </params>
    <attribs>
      <combo name="clocksource">
        <MenuEntries>
          <string>Internal</string>
          <string>External</string>
          <string>MIDI</string>
        </MenuEntries>
        <CEntries>
          <string>0</string>
          <string>1</string>
          <string>2</string>
        </CEntries>
      </combo>
      <combo name="device">
        <MenuEntries>
          <string>omni</string>
          <string>din</string>
          <string>usb host port 1</string>
          <string>usb host port 2</string>
          <string>usb host port 3</string>
          <string>usb host port 4</string>
          <string>internal port 1</string>
          <string>internal port 2</string>
          <string>usb device port 1</string>
        </MenuEntries>
        <CEntries>
          <string>MIDI_DEVICE_OMNI, 0</string>
          <string>MIDI_DEVICE_DIN, 1</string>
          <string>MIDI_DEVICE_USB_HOST, 1</string>
          <string>MIDI_DEVICE_USB_HOST, 2</string>
          <string>MIDI_DEVICE_USB_HOST, 3</string>
          <string>MIDI_DEVICE_USB_HOST, 4</string>
          <string>MIDI_DEVICE_INTERNAL, 1</string>
          <string>MIDI_DEVICE_INTERNAL, 2</string>
          <string>MIDI_DEVICE_USB_DEVICE, 1</string>
        </CEntries>
      </combo>
    </attribs>
    <code.declaration><![CDATA[

      //#define DEBUGF LogTextMessage
      #define DEBUGF(...) {}

      //#define USE_CLOCK_SMOOTHING

      enum
      {
        CLOCK_SOURCE_internal = 0,
        CLOCK_SOURCE_external = 1,
        CLOCK_SOURCE_midi     = 2
      } CLOCK_SOURCE;

      uint32_t  first_run;        // To catch first iteration for startup conditions
      uint32_t  ktimer;           // 3kHz timer
      uint32_t  phase;
      uint32_t  old_phase;
      uint32_t  old_24ppq;
      uint32_t  old_reset_sync;
      uint32_t  old_reset_imm;
      uint32_t  reset_sync;
      uint32_t  reset_imm;
      uint32_t  supress_trig;     // Avoid new gate on current step for stop -> run
      uint32_t  enforce_trig;     // Ensure that we get a retrigger on reset immediate if pressed when gate was on
      uint32_t  midi_clock_24;
      int32_t   step_count;       // The step counter
      int32_t   next_step_count;  // Pending new step number, or -1
      int32_t   old_step_count;
      uint32_t  midi_last_ktime;  // MIDI/24PPQ clock capture
      int32_t   midi_clock_freq;
      int32_t   midi_clock_div;
      int32_t   midi_clock_run;
      int32_t   midi_clock_count;
      int32_t   midi_transport;
#ifdef USE_CLOCK_SMOOTHING
      float     midi_last_period;
#endif

      // Sending MIDI clock
      ///  MidiSend1( (midi_device_t) attr_device, MIDI_START);
      ///  MidiSend1( (midi_device_t) attr_device, MIDI_CONTINUE);
      ///  MidiSend1( (midi_device_t) attr_device, MIDI_STOP);
      ///  MidiSend1( (midi_device_t) attr_device, MIDI_TIMING_CLOCK);

      __attribute__ ( ( always_inline ) ) __STATIC_INLINE int midi_device_test( midi_device_t dev, uint8_t port, int selected_dev, uint8_t selected_port )
      {
        if(    (selected_dev == MIDI_DEVICE_OMNI)
            || (selected_dev == dev && selected_port == port)
            )
          return 1;
        return 0;
      }

      void on_24ppq_clock( void )
      {
        if( midi_clock_run == 1  )
          {
            midi_clock_count++;
            midi_clock_24 = 1;

            if( midi_clock_count >= midi_clock_div )
              {
                // Find noof sample periods since last time;
                float period  = (ktimer - midi_last_ktime) * 16;
#ifdef USE_CLOCK_SMOOTHING
                // Leaky integrator to avoid spiky clock on tempo changes
                period = period + 0.1f * (midi_last_period - period);
                midi_last_period = period;
#endif
                if( period < 1.0f )
                  {
                    period == 1.0f;
                  }

                // Using slightly lower frequency (63.9 vs 64.0) so we avoid leading edge spikes from late phase resets.
                float f_clock = SAMPLERATE / period;
                double phi = 63.9 * (double)(1 << 30) * f_clock / (SAMPLERATE * 1.0);

                midi_clock_freq  = (uint32_t)phi;
                phase            = 0;
                midi_clock_count = 0;
                midi_last_ktime  = ktimer;

                DEBUGF("%d : CLOCK f*100 = %d,  pinc = 0x%08x, count = %d", ktimer, (int32_t)(f_clock * 100.0), midi_clock_freq, step_count );
              }
          }
      }

    ]]></code.declaration>
    <code.init><![CDATA[

      first_run        = 1;
      ktimer           = 0;
      phase            = 0;
      old_phase        = 0;
      old_24ppq        = 0;
      old_reset_sync   = 0;
      old_reset_imm    = 0;
      reset_sync       = 0;
      reset_imm        = 0;
      supress_trig     = 0;
      enforce_trig     = 0;
      step_count       = 0;
      next_step_count  = -1;
      old_step_count   = 0;
      midi_last_ktime  = 0;
      midi_clock_24    = 0;
      midi_clock_freq  = 0;
      midi_clock_div   = 12;
      midi_clock_run   = 1;
      midi_clock_count = 0;
      midi_transport   = 0;
#ifdef USE_CLOCK_SMOOTHING
      midi_last_period = 0.0f;
#endif

    ]]></code.init>
    <code.krate><![CDATA[

      int32_t freq;
      int32_t gatelength;

      // Reset output pulses
      outlet_clock = 0;
      outlet_24ppq = 0;
      outlet_start = 0;

      // Need some variable copies to resolve scope...
      midi_clock_div = param_clockdiv;
      midi_transport = param_miditransport;

      // 24 PPQ or MIDI sync input
      if( attr_clocksource == CLOCK_SOURCE_external )
        {
          if( inlet_24ppq > 0 && old_24ppq == 0 /*&& ktimer > 3*/  )
            {
              on_24ppq_clock();
            }
        }

      // Catch counter reset requests, with immediate reset taking priority

      if( inlet_rstimm > 0 && old_reset_imm == 0 )
        {
          reset_imm = 1;
        }
      else if( inlet_rstsync > 0 && old_reset_sync == 0 )
        {
          reset_sync = 1;
        }

      //if( inlet_run )
      if(   (inlet_run == 1 && attr_clocksource == CLOCK_SOURCE_internal)
         || (inlet_run == 1 && midi_clock_run == 1 )
        )
        {
          if( attr_clocksource == CLOCK_SOURCE_internal )
            {
              MTOFEXTENDED( param_tempo + inlet_tempo, freq );
              phase += freq>>2;
            }
          else
            {
              // Reclocking the internal LFO
              phase += midi_clock_freq;

              // Maintain 24 PPQ clock pulse
              if( midi_clock_24 )
                {
                  outlet_24ppq  = 1;
                  midi_clock_24 = 0;
                }
            }

          if( first_run )
            {
              DEBUGF( "%d : FIRST RUN", ktimer  );
              // Need to force a start pulse the very first run, since no count++ will trigger before the second step

              outlet_start = 1;
              first_run    = 0;
            }
          else if( phase < old_phase )
          //else if(    phase < old_phase
          //         && (    attr_clocksource == CLOCK_SOURCE_internal
          //              || midi_clock_run == 1
          //             )
          //       )
            {
              // Clock! Update counter, taking any queued song position into account.

              if( next_step_count >= 0 )
                {
                  step_count = next_step_count;
                  next_step_count = -1;
                }
              else if( inlet_reverse )
                {
                  step_count--;
                }
              else
                {
                  step_count++;
                }

              if( step_count < 0 )
                {
                  step_count = param_seqlength - 1;
                }
              else if( step_count >= param_seqlength )
                {
                  step_count = 0;
                }

              if( step_count == 0 )
                {
                  outlet_start = 1;
                }

              outlet_clock = 1;

              DEBUGF("%d : COUNT: count = %d,  next = %d", ktimer, step_count, next_step_count );
            }

          // Handle sequencer reset, either immediate or synchronized to the next step

          if( reset_imm == 1 )
            {
              DEBUGF( "RESET IMM" );
              phase        = 0;
              reset_imm    = 0;
              reset_sync   = 0;
              step_count   = 0;
              enforce_trig = 1;
            }
          else if( reset_sync == 1 )
            {
              if( phase < old_phase )
                {
                  DEBUGF( "RESET SYNC" );
                  phase      = 0;
                  reset_imm  = 0;
                  reset_sync = 0;
                  step_count = 0;
                }
            }

          // The gate length is variable from 0% to 100%

          gatelength = param_gatelength + inlet_gatelength;
          if( gatelength > (1<<27) )
            {
              gatelength  = (1<<27);
            }
          else if( gatelength < 0 )
            {
              gatelength  = 0;
            }

          // Handle the gate correctly for all cases
          //   Supressed trigger : avoids new gate on current step for stop -> run
          //   Enforced trigger  : force a new gate on reset immediate if pressed when the gate was on
          //   Normal trigger    : running gate pulse with variable gate length

          if( supress_trig )
            {
              DEBUGF( "SUPRESS TRIG" );
              outlet_gate = 0;
              if( step_count != old_step_count )
                {
                  supress_trig = 0;
                }
            }
          else if( enforce_trig )
            {
              DEBUGF( "ENFORCE TRIG" );
              outlet_gate  = 0;
              enforce_trig = 0;
            }
          else
            {
              if( (phase>>5) > gatelength )
                {
                  outlet_gate = 0;
                }
              else
                {
                  outlet_gate = 1;
                }
            }

          outlet_step    = step_count;
          old_step_count = step_count;
          old_phase      = phase;
        }
      else
        {
          outlet_gate  = 0;
          outlet_step  = step_count;
          supress_trig = 1;
        }

      old_24ppq      = inlet_24ppq;
      old_reset_sync = inlet_rstsync;
      old_reset_imm  = inlet_rstimm;
      ktimer++;

    ]]></code.krate>
    <code.midihandler><![CDATA[

      // http://www.blitter.com/~russtopia/MIDI/~jglatt/tech/midispec/seq.htm

      if( attr_clocksource == CLOCK_SOURCE_midi && midi_device_test( dev, port, attr_device ) == 1 )
        {
          if( status == MIDI_TIMING_CLOCK )
            {
              on_24ppq_clock();
            }
          else if( midi_transport )
            {
              if( status == MIDI_START )
                {
                  midi_clock_run   = 1;
                  midi_clock_count = 0;
                  //step_count       = 0;
                  next_step_count  = 0;
                }
              else if( status == MIDI_STOP )
                {
                  midi_clock_run = 0;
                }
              else if( status == MIDI_CONTINUE )
                {
                  midi_clock_run = 1;
                }
              else if( status == MIDI_SONG_POSITION )
                {
                  midi_clock_count = 0;
                  if( data1 == 0 && data2 == 0 )
                    {
                      next_step_count  = 0;
                    }
                  else
                    {
                      next_step_count  = 6 * ( (data2<<7) + data1 );
                    }
                }
            }
        }

    ]]></code.midihandler>
  </obj.normal>
</objdefs>